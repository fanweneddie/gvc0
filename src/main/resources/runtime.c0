#use <conio>
#use <string>

int runtime_hash(int index, int arrayLength)
    //@requires index >= 0;
    //@ensures \result >= 0 && \result < arrayLength;
{
  index = ((index >> 16) ^ index) * 0x45d9f3b;
  index = ((index >> 16) ^ index) * 0x45d9f3b;
  index = (index >> 16) ^ index;
  return index % arrayLength;
}

OwnedFields* runtime_init(){
  OwnedFields* fields = alloc(OwnedFields);
  fields->capacity = 128;
  fields->contents = alloc_array(FieldArray*, fields->capacity);
  return fields;
}

int runtime_countUnused(FieldArray*[] contents, int capacity, int newIndex) {
  int count = 0;
  for (int i = 0; i < capacity; i++) {
    if (i != newIndex && contents[i] != NULL && contents[i]->accessible == 0)
      count++;
  }
  return count;
}

// Called whenever a new element is added. Increments the `length` and resizes
// the backing array whenever necessary.
// `newIndex` specifies an index that will not be dropped, even if no fields in
// it are accessible (i.e., if it has just been added to the array).
void runtime_grow(OwnedFields* fields, int newIndex)
{
  int newLength = fields->length + 1;
  fields->length = newLength;

  // Keep the hash table's "load factor" under 80%
  // I.e., length is always < 80% of capacity
  int capacity = fields->capacity;
  if (newLength * 5 >= capacity * 4) {
    int GROW_CONST = 128;
    FieldArray*[] contents = fields->contents;

    // Check if we can gain enough space just by dropping unused entries
    int unused = runtime_countUnused(contents, capacity, newIndex);
    int newCapacity;
    if (unused >= GROW_CONST) {
      // Rehash with same size
      // NOTE: In this case we could do an in-place compaction, but this is
      // computationally expensive and results in difficult-to-understand code,
      // so we just copy into a new array, re-hashing and dropping unused
      // entries in the process
      newCapacity = capacity;
    } else {
      // Use a larger array and rehash
      newCapacity = capacity + GROW_CONST;
      fields->capacity = newCapacity;
    }

    FieldArray*[] newContents = alloc_array(FieldArray*, newCapacity);
    fields->contents = newContents;
    fields->length -= unused;

    // Add all items into the new array
    for (int i = 0; i < capacity; i++) {
      FieldArray* entry = contents[i];
      if (entry != NULL && (i == newIndex || entry->accessible != 0)) {
        int k = runtime_hash(entry->id, newCapacity);
        while (newContents[k] != NULL)
          k = (k + 1) % newCapacity;
        newContents[k] = entry;
      }
    }
  }
}

FieldArray* runtime_find(OwnedFields* fields, int id) {
  if (id >= 0) {
    FieldArray*[] contents = fields->contents;
    int capacity = fields->capacity;
    int index = runtime_hash(id, capacity);
    while (true) {
      FieldArray* entry = contents[index];
      if (entry == NULL)
        return NULL;
      else if (entry->id == id)
        return entry;
      else
        index = (index + 1) % capacity;
    }
  }

  return NULL;
}

// Add a new field array with the specified reference ID
// NOTE: This assumes that no field with the same reference ID have been added
FieldArray* runtime_newFieldArray(OwnedFields* fields, int id, int numFields) {
  FieldArray*[] contents = fields->contents;
  int capacity = fields->capacity;
  int index = runtime_hash(id, capacity);
  while (true) {
    FieldArray* entry = contents[index];
    if (entry == NULL) {
      // Insert new entry at this index
      entry = alloc(FieldArray);
      contents[index] = entry;
      entry->id = id;
      entry->length = numFields;
      entry->contents = alloc_array(bool, numFields);

      runtime_grow(fields, index);
      return entry;
    } else if (entry->accessible == 0) {
      // Overwrite unused
      entry->id = id;
      // Allow reusing the `contents` array if it has enough capacity
      // Since `accessible` is zero, all values must already be false
      if (entry->length < numFields)
        entry->contents = alloc_array(bool, numFields);
      entry->length = numFields;
      return entry;
    } else {
      index = (index + 1) % capacity;
    }
  }
  return NULL; // Never gets to this point
}

// Adds a new FieldArray and marks all fields as accessible
// NOTE: This assumes that no field with the same reference ID have been added
void runtime_addAll(OwnedFields* fields, int id, int numFields) {
  if (fields == NULL) return;

  FieldArray* entry = runtime_newFieldArray(fields, id, numFields);
  bool[] entryContents = entry->contents;
  for (int i = 0; i < numFields; i++){
    entryContents[i] = true;
  }
  entry->accessible = numFields;
}

// Adds the specified permission (id, fieldIndex) to the set of permissions.
// Returns false if permission already exists, otherwise returns true.
bool runtime_tryAdd(OwnedFields* fields, int id, int numFields, int fieldIndex) {
  int capacity = fields->capacity;
  FieldArray*[] contents = fields->contents;

  FieldArray* entry = runtime_find(fields, id);
  if (entry == NULL)
    entry = runtime_newFieldArray(fields, id, numFields);

  if (entry->contents[fieldIndex])
    return false;
  else
    entry->contents[fieldIndex] = true;
  entry->accessible++;

  return true;
}

// Adds the specified permission (id, fieldIndex) to the set of permissions.
// Throws `errorMessage` if the permission already exists.
void runtime_add(OwnedFields* fields, int id, int numFields, int fieldIndex, string errorMessage) {
  if (!runtime_tryAdd(fields, id, numFields, fieldIndex))
    error(errorMessage);
}

// Assert that the permission (id, fieldIndex) is already contained, otherwise
// throws `errorMessage`
void runtime_assert(OwnedFields* fields, int id, int fieldIndex, string errorMessage) {
  FieldArray* entry = runtime_find(fields, id);
  if (entry == NULL || !entry->contents[fieldIndex]){
    error(errorMessage);
  }
}

// Removes the permission (id, fieldIndex) from the set of permissions. Throws
// `errorMessage` if the permission does not exist.
void runtime_remove(OwnedFields* fields, int id, int fieldIndex, string errorMessage) {
  FieldArray* entry = runtime_find(fields, id);
  if (entry == NULL || !entry->contents[fieldIndex]) {
    error(errorMessage);
  }

  entry->contents[fieldIndex] = false;
  entry->accessible--;
}

void runtime_join(OwnedFields* target, OwnedFields* source) {
  if (target == NULL || source == NULL)
    return;

  int sourceCapacity = source->capacity;
  FieldArray*[] sourceContents = source->contents;
  for (int i = 0; i < sourceCapacity; i++) {
    FieldArray* sourceEntry = sourceContents[i];
    if (sourceEntry != NULL && sourceEntry->accessible != 0) {
      // Add all fields from `sourceEntry` to an existing or new entry in target
      int id = sourceEntry->id;
      FieldArray* targetEntry = runtime_find(target, id);
      if (targetEntry == NULL)
        targetEntry = runtime_newFieldArray(target, id, sourceEntry->length);

      // Assume that they both have the same length
      int length = sourceEntry->length;
      bool[] sc = sourceEntry->contents;
      bool[] tc = targetEntry->contents;
      for (int j = 0; j < length; j++) {
        if (sc[j]) {
          assert(!tc[j]);
          tc[j] = true;
        }
      }

      targetEntry->accessible += sourceEntry->accessible;
    }
  }
}

void runtime_print(OwnedFields* fields) {
  if (fields != NULL) {
    print("{ ");

    bool first = true;
    for (int i = 0; i < fields->capacity; i++) {
      FieldArray* entry = fields->contents[i];
      if (entry != NULL) {
        if (first) first = false;
        else print(", ");

        printf("%d@%d:", entry->id, i);
        for (int j = 0; j < entry->length; j++) {
          print(entry->contents[j] ? "X" : "_");
        }
      }
    }

    printf(" } (%d of %d)\n", fields->length, fields->capacity);
  } else {
    println("OwnedFields is empty/NULL");
  }
}